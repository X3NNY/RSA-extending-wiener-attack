

# This file was *autogenerated* from the file rsa_extending_wiener_attack.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_10 = Integer(10); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_4 = Integer(4); _sage_const_8 = Integer(8); _sage_const_0p5 = RealNumber('0.5'); _sage_const_1024 = Integer(1024); _sage_const_0x10001 = Integer(0x10001)
# set True to display details
debug = True

isdigit = lambda x: ord('0') <= ord(x) <= ord('9')

def my_permutations(g, n):
    sub = []
    res = []
    def dfs(s, prev):
        if len(s) == n:
            res.append(s[::])
        for i in g:
            if i in s or i < prev:
                continue
            s.append(i)
            dfs(s, max(prev, i))
            s.remove(i)
    dfs(sub, _sage_const_0 )
    return res

class X3NNY(object):
    def __init__(self, exp1, exp2):
        self.exp1 = exp1
        self.exp2 = exp2
    
    def __mul__(self, b):
        return X3NNY(self.exp1 * b.exp1, self.exp2 * b.exp2)

    def __repr__(self):
        return '%s = %s' % (self.exp1.expand().collect_common_factors(), self.exp2)

class X_Complex(object):
    def __init__(self, exp):
        i = _sage_const_0 
        s = '%s' % exp
        while i < len(s):
            if isdigit(s[i]):
                num = _sage_const_0 
                while i < len(s) and isdigit(s[i]):
                    num = num*_sage_const_10  + int(s[i])
                    i += _sage_const_1 
                if i >= len(s):
                    self.b = num
                elif s[i] == '*':
                    self.a = num
                    i += _sage_const_2 
                elif s[i] == '/':
                    i += _sage_const_1 
                    r = _sage_const_0 
                    while i < len(s) and isdigit(s[i]):
                        r = r*_sage_const_10  + int(s[i])
                        i += _sage_const_1 
                    self.b = num/r
            else:
                i += _sage_const_1 
        if not hasattr(self, 'a'):
            self.a = _sage_const_1 
        if not hasattr(self, 'b'):
            self.b = _sage_const_0 

def WW(e, d, k, g, N, s):
    return X3NNY(e*d*g-k*N, g+k*s)
def GG(e1, e2, d1, d2, k1, k2):
    return X3NNY(e1*d1*k2- e2*d2*k1, k2 - k1)

def W(i):
    e = eval("e%d" % i)
    d = eval("d%d" % i)
    k = eval("k%d" % i)
    return WW(e, d, k, g, N, s)

def G(i, j):
    e1 = eval("e%d" % i)
    d1 = eval("d%d" % i)
    k1 = eval("k%d" % i)
    
    e2 = eval("e%d" % j)
    d2 = eval("d%d" % j)
    k2 = eval("k%d" % j)
    
    return GG(e1, e2, d1, d2, k1, k2)

def R(e, sn): # min u max v
    ret = X3NNY(_sage_const_1 , _sage_const_1 )
    n = max(e)
    nn = len(e)
    l = set(i for i in range(_sage_const_1 , n+_sage_const_1 ))
    d = ''
    u, v = _sage_const_0 , _sage_const_0 
    for i in e:
        if i == _sage_const_1 :
            ret *= W(_sage_const_1 )
            d += 'W(%d)' % i
            nn -= _sage_const_1 
            l.remove(_sage_const_1 )
            u += _sage_const_1 
        elif i > min(l) and len(l) >= _sage_const_2 *nn:
            ret *= G(min(l), i)
            nn -= _sage_const_1 
            d += 'G(%d, %d)' % (min(l), i)
            l.remove(min(l))
            l.remove(i)
            v += _sage_const_1 
        else:
            ret *= W(i)
            l.remove(i)
            d += 'W(%d)' % i
            nn -= _sage_const_1 
            u += _sage_const_1 
    if debug:
        print(d)
    return ret, u/_sage_const_2  + (sn - v) * a

def H(n):
    if n == _sage_const_0 :
        return [_sage_const_0 ]
    if n == _sage_const_2 :
        return [(), (_sage_const_1 ,), (_sage_const_2 ,), (_sage_const_1 , _sage_const_2 )]
    ret = []
    for i in range(_sage_const_3 , n+_sage_const_1 ):
        ret.append((i,))
        for j in range(_sage_const_1 , i):
            for k in my_permutations(range(_sage_const_1 , i), j):
                ret.append(tuple(k + [i]))
    return H(_sage_const_2 ) + ret
    
def CC(exp, n):
    cols = [_sage_const_0  for i in range(_sage_const_1 <<n)]
    
    # split exp
    texps = ('%s' % exp.exp1.expand()).strip().split(' - ')
    ops = []
    exps = []
    for i in range(len(texps)):
        if texps[i].find(' + ') != -_sage_const_1 :
            tmp = texps[i].split(' + ')
            ops.append(_sage_const_0 )
            exps.append(tmp[_sage_const_0 ])
            for i in range(_sage_const_1 , len(tmp)):
                ops.append(_sage_const_1 )
                exps.append(tmp[i])
        else:
            ops.append(_sage_const_0 )
            exps.append(texps[i])
    if exps[_sage_const_0 ][_sage_const_0 ] == '-':
        for i in range(len(exps)):
            ops[i] = _sage_const_1 -ops[i]
        exps[_sage_const_0 ] = exps[_sage_const_0 ][_sage_const_1 :]
    else:
        ops[_sage_const_0 ] = _sage_const_1 
    # find e and N
    l = []
    for i in range(len(exps)):
        tmp = _sage_const_1  if ops[i] else -_sage_const_1 
        en = []
        j = _sage_const_0 
        while j < len(exps[i]):
            if exps[i][j] == 'e':
                num = _sage_const_0 
                j += _sage_const_1 
                while isdigit(exps[i][j]):
                    num = num*_sage_const_10  + int(exps[i][j])
                    j += _sage_const_1 
                tmp *= eval('e%d' % num)
                en.append(num)
            elif exps[i][j] == 'N':
                j += _sage_const_1 
                num = _sage_const_0 
                if exps[i][j] == '^':
                    j += _sage_const_1 
                    while isdigit(exps[i][j]):
                        num = num*_sage_const_10  + int(exps[i][j])
                        j += _sage_const_1 
                if num == _sage_const_0 :
                    num = _sage_const_1 
                tmp *= eval('N**%d' % num)
            else:
                j += _sage_const_1 
        if tmp == _sage_const_1  or tmp == -_sage_const_1 :
            l.append((_sage_const_0 , ()))
        else:
            l.append((tmp, tuple(sorted(en))))
    
    # construct h
    mp = H(n)
    for val, en in l:
        cols[mp.index(en)] = val
    # print(cols)
    return cols

def stirling(k):
    return factorial(k)/(factorial(k//_sage_const_2 )**_sage_const_2 )
def calcAlpha(n):
    if n % _sage_const_2  == _sage_const_1 :
        fz = (_sage_const_2 *n + _sage_const_1 ) * _sage_const_2 **n - _sage_const_4 *n*stirling(n-_sage_const_1 )
        fm = (_sage_const_2 *n - _sage_const_2 ) * _sage_const_2 **n + _sage_const_8 *n*stirling(n-_sage_const_1 )
    else:
        fz = (_sage_const_2 *n + _sage_const_1 ) * _sage_const_2 **n - (_sage_const_2 *n + _sage_const_1 )*stirling(n)
        fm = (_sage_const_2 *n - _sage_const_2 ) * _sage_const_2 **n + (_sage_const_4 *n + _sage_const_2 )*stirling(n)
    return fz/fm


def EWA(n, elist, NN, alpha):
    mp = H(n)
    var('a')
    S = [X_Complex(n*a)]
    cols = [[_sage_const_1  if i == _sage_const_0  else _sage_const_0  for i in range(_sage_const_2 **n)]]
    for i in mp[_sage_const_1 :]:
        eL, s = R(i, n)
        cols.append(CC(eL, n))
        S.append(X_Complex(s))
    
    alphaA,alphaB = _sage_const_0 , _sage_const_0 
    for i in S:
        alphaA = max(i.a, alphaA)
        alphaB = max(i.b, alphaB)
    D = []
    for i in range(len(S)):
        D.append(
            int(NN**((alphaA-S[i].a)*alpha + (alphaB - S[i].b)))
        )
    kw = {'N': NN}
    for i in range(len(elist)):
        kw['e%d' % (i+_sage_const_1 )] = elist[i]
    if debug:
        print("The lattice: ")
        print(Matrix(cols).T)
        
        print("The matrix D: ")
        print([N**((alphaA-S[i].a)*alpha + (alphaB - S[i].b)) for i in range(len(S))])

    B = Matrix(ZZ, Matrix(cols).T(**kw)) * diagonal_matrix(ZZ, D)
    L = B.LLL(_sage_const_0p5 )
    v = Matrix(ZZ, L[_sage_const_0 ])
    x = v * B**(-_sage_const_1 )
    phi = int(x[_sage_const_0 ,_sage_const_1 ]/x[_sage_const_0 ,_sage_const_0 ]*elist[_sage_const_0 ])
    return phi

def attack(NN, elist, alpha):
    for i in range(_sage_const_1 , len(elist)+_sage_const_1 ):
        var("e%d" % i)
        var("d%d" % i)
        var("k%d" % i)
    g, N, s = var('g'), var('N'), var('s')
    phi = EWA(len(elist), elist, NN, alpha)
    return phi

def example():
    from Crypto.Util.number import long_to_bytes, getPrime, bytes_to_long
    import uuid
    def rsa(e, n):
        m = uuid.uuid4().hex.encode()
        c = pow(bytes_to_long(m), e, n)
        return m.decode(), c
    p = getPrime(_sage_const_1024 )
    q = getPrime(_sage_const_1024 )
    
    # The modulus in RSA
    NN = p*q
    
    # The exponent in RSA
    e = _sage_const_0x10001 
    m, c = rsa(e, NN)
    print("The plaintext is:", m)
    
    # Theoretical upper bound in paper, but it is much smaller when actual test 
    alpha = calcAlpha(_sage_const_3 )
    print("Alpha: ",alpha)
    elist = [int(inverse_mod(getPrime(int(alpha * NN.bit_length())), (p-_sage_const_1 ) * (q-_sage_const_1 ))) for i in range(_sage_const_3 )]
    phi = attack(NN, elist, alpha)
    
    if phi != _sage_const_0 :
        print("Found Phi: ", phi)
        d = inverse_mod(e, phi)
        print("Bingo!The message is: ", long_to_bytes(pow(c, d, NN)))

if __name__ == "__main__":
    example()

